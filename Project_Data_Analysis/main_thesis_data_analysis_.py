# -*- coding: utf-8 -*-
"""MAIN: Thesis Data Analysis .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RhTEIFk_k0vor7idzL54K58qG0426JgX

# EXPERIMENT CSV SETUP
"""

import math
import matplotlib.pyplot as plt
import matplotlib_inline
import numpy as np
import pandas as pd
from itertools import product
from collections import defaultdict
import io
import pandas as pd
pd.read_csv(io.StringIO('''
Turbulence Experiments,Starting Altitude (AGL),Wind Layer Altitude,Wind Direction,Wind Speed,Turbulence,Thermal Rate,Thermal Percent,Thermal Altitude
'''), header=None)
headers = ['Starting Altitude (AGL)','Wind Layer Altitude','Wind Direction','Wind Speed','Turbulence','Thermal Rate','Thermal Percent', 'Thermal Altitude','Cognitive Delay']
startingAltitudeList = [2900]
windLayerAltitudes = [0]
windDirections = [179]
windSpeeds = [0]
turbulence = [1,2,3,4,5,6,7,8,9,10]
thermalRates = [500]
thermalPercent = [0.9]
thermalAltitude = [15000]
cognitiveDelay = [0.05,0.15,0.25,0.35,0.45,0.55]
paramGenerator = product(startingAltitudeList,windLayerAltitudes,windDirections,windSpeeds,turbulence,thermalRates,thermalPercent,thermalAltitude,cognitiveDelay)

list1 = list(paramGenerator)
# list1

df = pd.DataFrame(list1, columns=headers)
df['Turbulence Experiments'] = np.arange(len(list1))

column_to_move = df.pop('Turbulence Experiments')
df.insert(0, "Turbulence Experiments", column_to_move)


df.head()


df.to_csv('turbulence.csv', index=False)

# row = 1
# for e in list1:
#   df[]

# len(df)

times = [
    211.99490690231323, 414.6603558063507, 620.0434548854828, 823.7415471076965,
    1030.7869319915771, 1239.648246049881, 1429.8520970344543, 1629.9112830162048,
    1828.540177822113, 2018.2677998542786, 2210.3551049232483, 2394.5315730571747,
    2594.051417827606, 2773.5785989761353, 2959.184391975403, 3134.061397075653,
    3305.022227048874, 3384.593410730362, 3549.242175102234, 3709.0278537273407,
    3877.4993739128113, 3969.0503737926483, 4141.003606796265, 4306.93811583519,
    4474.568394899368, 5011.591106891632, 5172.550608873367, 5285.527490854263,
    5998.327862024307, 6098.2435920238495, 6210.676140069962, 6323.69210767746,
    6463.504940032959, 6552.847650766373, 6691.104147911072, 6819.9902946949005,
    6945.423458814621, 7057.30597782135, 7199.7377207279205, 7334.88204908371,
    7483.229276895523, 7591.977308988571, 7671.840399980545, 7769.087654829025,
    7879.367015838623, 7981.9824867248535, 8074.482370853424, 8189.868643760681,
    8245.625082969666, 8304.064481019974, 8395.517117977142, 8480.387871026993,
    9264.566101074219, 9342.230458974838, 9410.582926750183, 9492.828332901001,
    9579.739105701447, 9664.122803926468, 9746.938753843307
]

# Print the time at row 1
print(f"Row 1 Time: {times[0]}")

# Calculate and print the differences
for i in range(len(times) - 1):
    diff = round(times[i+1] - times[i], 6)
    print(f"Row {i+2}: {diff}")

# Print the time at row 60
print(f"Row 60 Time: {times[-1]}")

import pandas as pd

# List of time values
times = [
    211.99490690231323, 414.6603558063507, 620.0434548854828, 823.7415471076965,
    1030.7869319915771, 1239.648246049881, 1429.8520970344543, 1629.9112830162048,
    1828.540177822113, 2018.2677998542786, 2210.3551049232483, 2394.5315730571747,
    2594.051417827606, 2773.5785989761353, 2959.184391975403, 3134.061397075653,
    3305.022227048874, 3384.593410730362, 3549.242175102234, 3709.0278537273407,
    3877.4993739128113, 3969.0503737926483, 4141.003606796265, 4306.93811583519,
    4474.568394899368, 5011.591106891632, 5172.550608873367, 5285.527490854263,
    5998.327862024307, 6098.2435920238495, 6210.676140069962, 6323.69210767746,
    6463.504940032959, 6552.847650766373, 6691.104147911072, 6819.9902946949005,
    6945.423458814621, 7057.30597782135, 7199.7377207279205, 7334.88204908371,
    7483.229276895523, 7591.977308988571, 7671.840399980545, 7769.087654829025,
    7879.367015838623, 7981.9824867248535, 8074.482370853424, 8189.868643760681,
    8245.625082969666, 8304.064481019974, 8395.517117977142, 8480.387871026993,
    9264.566101074219, 9342.230458974838, 9410.582926750183, 9492.828332901001,
    9579.739105701447, 9664.122803926468, 9746.938753843307
]

# Compute differences
diffs = [round(times[i+1] - times[i], 6) for i in range(len(times) - 1)]

# Combine time at Row 1, all diffs, and time at Row 60
all_data = [times[0]] + diffs + [times[-1]]

# Create correct number of labels
labels = ["Row 1 Time"] + [f"Row {i+1} Diff" for i in range(1, len(times))] + ["Row 60 Time"]

# Sanity check: ensure labels and data match
assert len(labels) == len(all_data), "Label and data lengths don't match!"

# Create DataFrame
df = pd.DataFrame({'Label': labels, 'Value': all_data})

# Reshape into 10-row chunks
chunks = [df.iloc[i:i+10].reset_index(drop=True) for i in range(0, len(df), 10)]

# Rename columns for each chunk
for i, chunk in enumerate(chunks):
    chunk.columns = pd.MultiIndex.from_product([[f'Col {i+1}'], ['Label', 'Value']])
    chunks[i] = chunk

# Concatenate into final table
final_table = pd.concat(chunks, axis=1)

# Display result
print(final_table)
final_table.head()

"""#Data Analysis"""

!pip install utm

import math
import matplotlib.pyplot as plt
import matplotlib_inline
import numpy as np
import pandas as pd
import utm
import pickle
import matplotlib.patches as patches


matplotlib_inline.backend_inline.set_matplotlib_formats('svg')

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

def to_point(lat, lon):
    x, y, _, _ = utm.from_latlon(lat, lon)
    return 3.28084 * np.array([x, y])

RUNWAY_START = to_point(39.895791, -104.696085)
RUNWAY_END = to_point(39.851898, -104.6966)

def get_distance(pt1, pt2):
  A = (pt2 - pt1)
  return A[1]
    # return np.linalg.norm(pt2 - pt1)

def get_lateral_deviation(pt):
    p1 = RUNWAY_START
    p2 = RUNWAY_END
    return np.cross(p2-p1, p1-pt) / np.linalg.norm(p2 - p1)

dfArray  = []
for x in range (1,61):
  if(x != 1000 and x != 1000):
    # dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination/Data Storage/MainExperiment2_2025-04-14 11:33:24.588625/"
    # experimentFile = "/Main_" + str(experimentNum) + "_.txt"
    # experimentFile = "MainExperiment1--Turbulence Experiments_" + str(experimentNum) + "_.txt"

    dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination/Data Storage/Redo--Turbulence Experiments 2025-05-01 22:49:02.525104/"
    experimentNum = x
    experimentFile =  str(experimentNum) + "_Redo--Turbulence Experiments" ".txt"
    currentExperiment = dataFolder + experimentFile
    # currentExperiment = "/content/Data.txt"
    df = pd.read_csv(currentExperiment)
    df.columns = df.columns.str.replace(' ', '')
    LAT = 'Latitude'
    LON = 'Longitude'
    ALT = 'Altitude'
    PITCH = 'Pitch'
    ROLL = 'Roll'
    DIST = '_dist,___ft'
    LATDEV = 'latdev'
    LANDED = 'landed'
    IDEAL_ALT = 'ideal_alt'
    ZERO = 'zero'
    df = df.dropna()

    pts = df.apply(lambda row: to_point(row[LAT], row[LON]), axis=1)
    dist = df.apply(lambda row: get_distance(RUNWAY_START,to_point(row[LAT],row[LON])), axis=1)
    df[DIST] = dist

    df[LANDED] = df[ALT] < 0.5
    # df.columns
    # color = np.random.randint(0, 3, size = n)
    df[LATDEV] = [get_lateral_deviation(pt) for pt in pts]
    df[LANDED] = df[ALT] < 0.5
    df[LANDED]
    dfArray.append(df)
  # else:
  #   # dfArray.append()
len(dfArray)
##Save so we dont have to runthis again.....
with open('dataFrameArray.pkl', 'wb') as file:
  pickle.dump(dfArray, file)

"""Don't read all those CSV's again"""

dfArray  = []
LAT = 'Latitude'
LON = 'Longitude'
ALT = 'Altitude'
PITCH = 'Pitch'
ROLL = 'Roll'
DIST = '_dist,___ft'
LATDEV = 'latdev'
LANDED = 'landed'
IDEAL_ALT = 'ideal_alt'
ZERO = 'zero'
# dfArray = pd.read_pickle("/content/dataFrameArray.pkl")
with open('dataFrameArray.pkl', 'rb') as file:
  # dfArray = pickle.Unpickler(file)
  dfArray = pickle.load(file)

!pip install colour

from colour import Color
green = Color("green")
colors = list(green.range_to(Color("red"),10))

def hex_to_RGB(hex_str):
    """ #FFFFFF -> [255,255,255] """
    #Pass 16 to the integer function for change of base
    return [int(hex_str[i:i+2], 16) for i in range(1,6,2)]

def get_color_gradient(c1, c2, n):
    """
    Given two hex colors, returns a color gradient
    with n colors.
    """
    assert n > 1
    c1_rgb = np.array(hex_to_RGB(c1))/255
    c2_rgb = np.array(hex_to_RGB(c2))/255
    mix_pcts = [x/(n-1) for x in range(n)]
    rgb_colors = [((1-mix)*c1_rgb + (mix*c2_rgb)) for mix in mix_pcts]
    return ["#" + "".join([format(int(round(val*255)), "02x") for val in item]) for item in rgb_colors]

colors = get_color_gradient("#00FF00","#FF0000",10)
fig, axes = plt.subplots(6, 4, figsize=(32, 4 * 4),layout="constrained")
# fig.tight_layout()
# fig.use()

# axes[0].set_aspect(1)
# axes[1].set_aspect(1)
turbulenceLevelCount = 0
turbLevel = 0

def drawAllowed(input):
  allowedArray = [1,5,10];
  # allowedArray = [1,2,3,4,5,6,7,8,9,10];
  allowed = False;
  for x in allowedArray:
    if(input == x):
      allowed = True;
      return allowed
  return allowed




axes[0,0].set_title("50 Milliseconds")
axes[1,0].set_title("150 Milliseconds")
axes[2,0].set_title("250 Milliseconds")
axes[3,0].set_title("350 Milliseconds")
axes[4,0].set_title("450 Milliseconds")
axes[5,0].set_title("550 Milliseconds")
handles = ["T1","T2","T3","T4","T5","T6","T7","T8","T9","T10"]
cols = ["Altitude","Roll","Pitch","Lateral Deviation from Runway Centerline"]
cols2 = ["Altitude(Feet)","Roll(Degrees)","Pitch(Degrees)","Lateral Deviation(Feet)"]
timings = ["50 Milliseconds","150 Milliseconds","250 Milliseconds","350 Milliseconds","450 Milliseconds","550 Milliseconds"]

for x in range(len(axes)):
  for c, y, ax in zip(cols,cols2, axes[x]):
      ax.set_title(c + ": " + timings[x], size='large', pad=20)
      ax.set_xlabel("Distance from Runway (feet)")
      ax.set_ylabel(y)        ## column dep.
      # ax.set_xlim(-5000,25000)
      ax.set_xlim(25000,-5000)

      if(c == "Altitude"):
          ax.set_ylim(0,1000)
      if(c == "Roll"):
        ax.set_ylim(-90,90)
        ax.axhline(y=45, linewidth=3,color=(0,0,0,0.5),linestyle='--')
        ax.axhline(y=-45, linewidth=3,color=(0,0,0,0.5),linestyle='--')
      if(c == "Pitch"):
        ax.set_ylim(-25,25)
      if(c == "Lateral Deviation from Runway Centerline"):
        ax.set_ylim(-1500,1500)

##Setting the "Decorations"
for r in range (0,6):
  for c in range (0,4):
    axes[r,c].axvline(x=0, linewidth=2,color="red",linestyle=':')
    # axes[r,c].axhline(y=0,xmin=-5000, xmax=200, linewidth=5,color="blue",linestyle='-')
    if(c != 3):
      rect = patches.Rectangle((-5000, -5000), 5500, 5300, linewidth=1, edgecolor='r', facecolor= (1,0,0,0.1))
      rect2 = patches.Rectangle((-5000, -5000), 10280, 5300, linewidth=1, edgecolor='b', facecolor= (0,0,1,0.1))
    else:
      rect = patches.Rectangle((-5000, -5000), 5500, 10000, linewidth=1, edgecolor='r', facecolor= (1,0,0,0.1))
      rect2 = patches.Rectangle((-5000, -5000), 10280, 10000, linewidth=1, edgecolor='b', facecolor= (0,0,1,0.1))


    axes[r,c].add_patch(rect2)
    axes[r,c].add_patch(rect)

    axes[r,c].annotate('Runway Environment',
            xy=(-2500, axes[r,c].get_ylim()[1]), # Coordinates of the point to annotate
            xytext=(-2500, axes[r,c].get_ylim()[1]), # Coordinates of the text
            arrowprops=dict(facecolor='black', shrink=0.05), # Arrow properties
            horizontalalignment='center',
            verticalalignment='bottom', fontsize=8, color = 'red')

    axes[r,c].annotate('Within 1 Mile',
            xy=(2500, axes[r,c].get_ylim()[1]), # Coordinates of the point to annotate
            xytext=(2500, axes[r,c].get_ylim()[1]), # Coordinates of the text
            arrowprops=dict(facecolor='black', shrink=0.05), # Arrow properties
            horizontalalignment='center',
            verticalalignment='bottom', fontsize=8,color = 'blue')


for x in range (0,len(dfArray)):
  #Set Current Turbulence Level
  if(turbulenceLevelCount % 6 == 0):
    turbLevel +=1
    #Set Color of Line to represent milliseconds

#Plot Color based on milliseconds
  # color1='tab:orange'
  # if(x%6 == 3): #0.05
  #   color1 = 'tab:blue'
  # elif (x%6 == 4): #0.15
  #   color1 = 'tab:green'
  # elif (x%6 == 5): #0.25
  #   color1 = 'tab:red'
  # elif (x%6 == 0): #0.35
  #   color1 = 'tab:purple'
  # elif (x%6 == 1): #0.45
  #   color1 = 'tab:pink'
  # elif (x%6 == 2): #0.55
  #   color1 = 'tab:cyan'
  # else:
  #   color1 ='tab:orange'


# #plot color based on turbulence Level
#   if(turbLevel == 1): #0.05
#     color1 = 'tab:blue'
#   elif (turbLevel == 2): #0.15
#     color1 = 'tab:green'
#   elif (turbLevel == 3): #0.25
#     color1 = 'tab:red'
#   elif (turbLevel == 4): #0.35
#     color1 = 'tab:purple'
#   elif (turbLevel == 5): #0.45
#     color1 = 'tab:pink'
#   elif (turbLevel == 6): #0.55
#     color1 = 'tab:cyan'
#   elif (turbLevel == 7): #0.55
#     color1 = 'lightcoral'
#   elif (turbLevel == 8): #0.55
#     color1 = 'magenta'
#   elif (turbLevel == 9): #0.55
#     color1 = 'crimson'
#   elif (turbLevel == 10): #0.55
#     color1 ='tab:orange'
#   else:
#     color1 ='tab:orange'



#plot color based on turbulence Level (GRADIENT VERSION)
  color1 = colors[turbLevel-1]

  # if(turbLevel == 1): #0.05
  #   color1 = colors[0]
  # elif (turbLevel == 2): #0.15
  #   color1 = colors[1]
  # elif (turbLevel == 3): #0.25
  #   color1 = colors[2]
  # elif (turbLevel == 4): #0.35
  #   color1 = colors[3]
  # elif (turbLevel == 5): #0.45
  #   color1 = colors[4]
  # elif (turbLevel == 6): #0.55
  #   color1 = colors[5]
  # elif (turbLevel == 7): #0.55
  #   color1 = colors[6]
  # elif (turbLevel == 8): #0.55
  #   color1 = colors[7]
  # elif (turbLevel == 9): #0.55
  #   color1 = colors[8]
  # elif (turbLevel == 10): #0.55
  #   color1 = colors[9]
  # else:
  #   color1 ='tab:orange'

  ##Group by Milliseconds DIST VS ALTITUDE
  df = dfArray[x];
  if(drawAllowed(turbLevel)):
    axes[(x%6),0].plot(df[DIST], df[ALT], color=color1, linestyle='--')
    # if(x % 6 == 0):
    #     if(drawAllowed(turbLevel)):
    #       axes[0,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # elif(x % 6 == 1):
    #   if(drawAllowed(turbLevel)):
    #       axes[1,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # elif(x % 6 == 2):
    #   if(drawAllowed(turbLevel)):
    #       axes[2,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # elif(x % 6 == 3):
    #   if(drawAllowed(turbLevel)):
    #       axes[3,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # elif(x % 6 == 4):
    #   if(drawAllowed(turbLevel)):
    #       axes[4,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # elif(x % 6 == 5):
    #   if(drawAllowed(turbLevel)):
    #       axes[5,0].plot(df[DIST], df[ALT], color= color1, linestyle='--')

  ##Group by Milliseconds DIST VS ROLL
    axes[(x%6),1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')

    # if(x % 6 == 0):
    #       axes[0,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')
    # elif(x % 6 == 1):
    #       axes[1,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')
    # elif(x % 6 == 2):
    #       axes[2,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')
    # elif(x % 6 == 3):
    #       axes[3,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')
    # elif(x % 6 == 4):
    #       axes[4,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')
    # elif(x % 6 == 5):
    #       axes[5,1].plot(df[DIST], df[ROLL], color= color1, linestyle='--')


    axes[(x%6),2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')


    ##Group by Milliseconds DIST VS ROLL
    # if(x % 6 == 0):
    #       axes[0,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')
    # elif(x % 6 == 1):
    #       axes[1,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')
    # elif(x % 6 == 2):
    #       axes[2,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')
    # elif(x % 6 == 3):
    #       axes[3,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')
    # elif(x % 6 == 4):
    #       axes[4,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')
    # elif(x % 6 == 5):
    #       axes[5,2].plot(df[DIST], df[PITCH], color= color1, linestyle='--')


    ##Group by Milliseconds DIST VS ROLL
    axes[(x%6),3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')

    # if(x % 6 == 0):
    #       axes[0,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')
    # elif(x % 6 == 1):
    #       axes[1,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')
    # elif(x % 6 == 2):
    #       axes[2,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')
    # elif(x % 6 == 3):
    #       axes[3,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')
    # elif(x % 6 == 4):
    #       axes[4,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')
    # elif(x % 6 == 5):
    #       axes[5,3].plot(df[DIST], df[LATDEV], color= color1, linestyle='--')

  turbulenceLevelCount = turbulenceLevelCount + 1

# LAT = 'Latitude'
# LON = 'Longitude'
#     ALT = 'Altitude'
#     PITCH = 'Pitch'
#     ROLL = 'Roll'
#     DIST = '_dist,___ft'
#     LATDEV = 'latdev'
#     LANDED = 'landed'
#     IDEAL_ALT = 'ideal_alt'
#     ZERO = 'zero'

fig.legend()
plt.savefig('/content/sample_data/COMPOSITE')

"""#SUMMARY STATISTICS SECTION"""

#Calculating Average Lateral Deviation Per Trial, grouping by reaction timing
avgLatDevArrayTurbulence = [[],[],[],[],[],[],[],[],[],[]] # Rows are turbulence Levels, Columns are reaction times

#Calculating Average Lateral Deviation Per Trial, grouping by turbulence Level
avgLatDevArrayReaction = [[],[],[],[],[],[]] #Rows are reaction times, columns are turbulence Levels
#0.5,0.15,25,35,45,55

turbLevel = 0
turbulenceLevelCount = 0

reactionLevel = 0

for x in range (0,len(dfArray)):
  df = dfArray[x];
  if(turbulenceLevelCount % 6 == 0):
    turbLevel += 1;
    reactionLevel = 0

  currIndexReactionTime = int(turbLevel)-1;
  currIndexTurbulenceLevel = reactionLevel;

  calculatedMean = float(df[LATDEV].mean());
  avgLatDevArrayTurbulence[currIndexReactionTime].append(calculatedMean);

  avgLatDevArrayReaction[currIndexTurbulenceLevel].append(calculatedMean);

  turbulenceLevelCount += 1;
  reactionLevel +=1;

avgLatDevArrayTurbulence
# avgLatDevArrayReaction



#Calculating Mean Squared Error for lateral deviation for each turbulence level
df = pd.DataFrame()
turbLevelMSE = []
# avgLatDevArrayTurbulence[1]

for x in range(0,len(avgLatDevArrayTurbulence[0])):
    df[x] = avgLatDevArrayTurbulence[x]
  # avgLatDevArrayTurbulence[x] = avgLatDevArrayTurbulence[x]**2
  # avgLatDevArrayTurbulence.mean()

# df[0] = df[0]**2;

# np.sqrt(df[0].mean())
# len(df)
for x in range(0,df.shape[1]):
  df[x] = df[x]**2;
  calcMean = np.sqrt(df[x].mean())
  turbLevelMSE.append(float(calcMean))
turbLevelMSE

#Calculating Mean Squared Error for lateral deviation for each turbulence level
df = pd.DataFrame()
turbLevelMSE = []
# avgLatDevArrayTurbulence[1]

for x in range(0,len(avgLatDevArrayTurbulence[0])):
    df[x] = avgLatDevArrayTurbulence[x]
  # avgLatDevArrayTurbulence[x] = avgLatDevArrayTurbulence[x]**2
  # avgLatDevArrayTurbulence.mean()

# df[0] = df[0]**2;

# np.sqrt(df[0].mean())
# len(df)
for x in range(0,df.shape[1]):
  df[x] = df[x]**2;
  calcMean = np.sqrt(df[x].mean())
  turbLevelMSE.append(float(calcMean))
turbLevelMSE

#Calculating Roll Per Trial, grouping by reaction timing
avgRollArrayTurbulence = [[],[],[],[],[],[],[],[],[],[]] # Rows are turbulence Levels, Columns are reaction times

#Calculating Roll Deviation Per Trial, grouping by turbulence Level
avgRollArrayReaction = [[],[],[],[],[],[]] #Rows are reaction times, columns are turbulence Levels
#0.5,0.15,25,35,45,55

turbLevel = 0
turbulenceLevelCount = 0

reactionLevel = 0

for x in range (0,len(dfArray)):
  df = dfArray[x];
  #Turning into MSE compatible
  df[ROLL] = 0 - df[ROLL];


  if(turbulenceLevelCount % 6 == 0):
    turbLevel += 1;
    reactionLevel = 0

  currIndexReactionTime = int(turbLevel)-1;
  currIndexTurbulenceLevel = reactionLevel;

  calculatedMean = float(df[ROLL].mean());
  avgRollArrayTurbulence[currIndexReactionTime].append(calculatedMean);

  avgRollArrayReaction[currIndexTurbulenceLevel].append(calculatedMean);

  turbulenceLevelCount += 1;
  reactionLevel +=1;

avgRollArrayTurbulence
avgRollArrayReaction

#Calculating Mean Squared Error for roll for each turbulence level
df = pd.DataFrame()
turbLevelMSERoll = []
# avgLatDevArrayTurbulence[1]

for x in range(0,len(avgRollArrayTurbulence[0])):
    df[x] = avgRollArrayTurbulence[x]
  # avgLatDevArrayTurbulence[x] = avgLatDevArrayTurbulence[x]**2
  # avgLatDevArrayTurbulence.mean()

# df[0] = df[0]**2;

# np.sqrt(df[0].mean())
# len(df)
for x in range(0,df.shape[1]):
  df[x] = df[x]**2;
  calcMean = np.sqrt(df[x].mean())
  turbLevelMSERoll.append(float(calcMean))
turbLevelMSERoll

# df = pd.DataFrame()
# df[0] = turbLevelMSERoll

#Calculating Pitch Per Trial, grouping by reaction timing
avgPitchArrayTurbulence = [[],[],[],[],[],[],[],[],[],[]] # Rows are turbulence Levels, Columns are reaction times

#Calculating Pitch Deviation Per Trial, grouping by turbulence Level
avgPitchArrayReaction = [[],[],[],[],[],[]] #Rows are reaction times, columns are turbulence Levels
#0.5,0.15,25,35,45,55

turbLevel = 0
turbulenceLevelCount = 0

reactionLevel = 0

for x in range (0,len(dfArray)):
  df = dfArray[x];
  #Turning into MSE compatible
  df[PITCH] = 0 - df[PITCH];


  if(turbulenceLevelCount % 6 == 0):
    turbLevel += 1;
    reactionLevel = 0

  currIndexReactionTime = int(turbLevel)-1;
  currIndexTurbulenceLevel = reactionLevel;

  calculatedMean = float(df[PITCH].mean());
  avgPitchArrayTurbulence[currIndexReactionTime].append(calculatedMean);

  avgPitchArrayReaction[currIndexTurbulenceLevel].append(calculatedMean);

  turbulenceLevelCount += 1;
  reactionLevel +=1;

avgPitchArrayTurbulence
avgPitchArrayReaction

#Calculating Mean Squared Error for roll for each turbulence level
df = pd.DataFrame()
turbLevelMSEPitch = []
# avgLatDevArrayTurbulence[1]

for x in range(0,len(avgRollArrayTurbulence[0])):
    df[x] = avgPitchArrayTurbulence[x]
  # avgLatDevArrayTurbulence[x] = avgLatDevArrayTurbulence[x]**2
  # avgLatDevArrayTurbulence.mean()

# df[0] = df[0]**2;

# np.sqrt(df[0].mean())
# len(df)
for x in range(0,df.shape[1]):
  df[x] = df[x]**2;
  calcMean = np.sqrt(df[x].mean())
  turbLevelMSEPitch.append(float(calcMean))
turbLevelMSEPitch

# df = pd.DataFrame()
# df[0] = turbLevelMSERoll

df = pd.DataFrame()
df["LATERAL DEVIATION"] = turbLevelMSE
df["ROLL"] = turbLevelMSERoll
df["PITCH"] = turbLevelMSEPitch

df

# dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination"
# experimentNum = 4
# experimentFile = "/Wind Experiments_" + str(experimentNum) + "_.txt"

dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination/Data Storage/MainExperiment2_2025-04-14 11:33:24.588625/"
experimentNum = 3
experimentFile = "/Main_" + str(experimentNum) + "_.txt"
experimentFile = "MainExperiment1--Turbulence Experiments_" + str(experimentNum) + "_.txt"
currentExperiment = dataFolder + experimentFile
# currentExperiment = "/content/Data.txt"
df = pd.read_csv(currentExperiment)

df.columns = df.columns.str.replace(' ', '')
df.head()
df.insert(1, "_dist,___ft")

df.columns

LAT = 'Latitude'
LON = 'Longitude'
ALT = 'Altitude'
PITCH = 'Pitch'
ROLL = 'Roll'
DIST = '_dist,___ft'
LATDEV = 'latdev'
LANDED = 'landed'
IDEAL_ALT = 'ideal_alt'
ZERO = 'zero'
df = df.dropna()


df[LANDED] = df[ALT] < 0.5
# df.columns
pts = df.apply(lambda row: to_point(row[LAT], row[LON]), axis=1)
dist = df.apply(lambda row: get_distance(RUNWAY_START,to_point(row[LAT],row[LON])), axis=1)

df[LATDEV] = [get_lateral_deviation(pt) for pt in pts]
df[LANDED] = df[ALT] < 0.5
df[LANDED]
df[DIST] = dist
plot = plt.plot(df[DIST], df[ALT], color='tab:orange', linestyle='--')
plt.gca().set_aspect(6)


# plt.subplot(412)
# plt.ylabel('Lateral Deviation (ft)')
# plt.ylim(
#          min(-1000, df[LATDEV].min()-10),
#          max( 1000, df[LATDEV].max()+10)
#          )
# plt.plot(df[DIST], df[LATDEV])
# plt.plot(df[DIST], df[ZERO], color='tab:orange', linestyle='--')

# touchdown_dist = df[df[LANDED]].iloc[0][DIST]

# df[IDEAL_ALT] = [
#     (touchdown_dist - dist) * math.tan(3.0 * (math.pi / 180))
#     if dist < touchdown_dist
#     else 0
#     for dist in df[DIST]
# ]

# df[ZERO] = np.zeros(len(df))

"""VERSION 1"""

turbulenceCount = 0
for x in range (3,61):
  if(x != 27):
    dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination/Data Storage/MainExperiment2_2025-04-14 11:33:24.588625/"
    experimentNum = x
    experimentFile = "/Main_" + str(experimentNum) + "_.txt"
    experimentFile = "MainExperiment1--Turbulence Experiments_" + str(experimentNum) + "_.txt"
    currentExperiment = dataFolder + experimentFile
    # currentExperiment = "/content/Data.txt"
    df = pd.read_csv(currentExperiment)


    color1='tab:orange'
    if(x%6 == 3): #0.05
      color1 = 'tab:blue'
    elif (x%6 == 4): #0.15
      color1 = 'tab:green'
    elif (x%6 == 5): #0.25
      color1 = 'tab:red'
    elif (x%6 == 0): #0.35
      color1 = 'tab:purple'
    elif (x%6 == 1): #0.45
      color1 = 'tab:pink'
    elif (x%6 == 2): #0.55
      color1 = 'tab:cyan'
    else:
      color1 ='tab:orange'

    df.columns = df.columns.str.replace(' ', '')
    df.head()
    # df.insert(1,"_dist,___ft")
    df.columns

    LAT = 'Latitude'
    LON = 'Longitude'
    ALT = 'Altitude'
    PITCH = 'Pitch'
    ROLL = 'Roll'
    DIST = '_dist,___ft'
    LATDEV = 'latdev'
    LANDED = 'landed'
    IDEAL_ALT = 'ideal_alt'
    ZERO = 'zero'
    df = df.dropna()

    pts = df.apply(lambda row: to_point(row[LAT], row[LON]), axis=1)
    dist = df.apply(lambda row: get_distance(RUNWAY_START,to_point(row[LAT],row[LON])), axis=1)
    df[DIST] = dist

    df[LANDED] = df[ALT] < 0.5
    # df.columns

    # color = np.random.randint(0, 3, size = n)


    df[LATDEV] = [get_lateral_deviation(pt) for pt in pts]
    df[LANDED] = df[ALT] < 0.5
    df[LANDED]
    ax = plt.plot(df[DIST], df[ALT], color= color1, linestyle='--')
    # plt.gca().set_aspect(6)
    plt.savefig('/content/sample_data/Figures/figure_' + str(x))
    # fig.savefig('/content/sample_data/figure_' + str(x))
    turbulenceCount = turbulenceCount+1

!zip -r figures.zip sample_data/Figures

# df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/flight/data.csv')
df = pd.read_csv(currentExperiment, sep='\t')
df = df.dropna()

LAT = '__lat,__deg'
LON = '__lon,__deg'
ALT = '__alt,ftagl'
PITCH = 'pitch,__deg'
ROLL = '_roll,__deg'
DIST = '_dist,___ft'
LATDEV = 'latdev'
LANDED = 'landed'
IDEAL_ALT = 'ideal_alt'
ZERO = 'zero'

pts = df.apply(lambda row: to_point(row[LAT], row[LON]), axis=1)

df[LATDEV] = [get_lateral_deviation(pt) for pt in pts]

df[LANDED] = df[ALT] < 0.5

touchdown_dist = df[df[LANDED]].iloc[0][DIST]
df[IDEAL_ALT] = [
    (touchdown_dist - dist) * math.tan(3.0 * (math.pi / 180))
    if dist < touchdown_dist
    else 0
    for dist in df[DIST]
]

df[ZERO] = np.zeros(len(df))

"""# DR Salvucci's Code:"""

dataFolder = "/content/drive/MyDrive/2. 游니PENN Tower on 126.6游니/4c. Penn Spring 2025/8. Research/7. Experiments/Test Destination"
experimentNum = 2
experimentFile = "/Wind Experiments_" + str(experimentNum) + "_.txt"

currentExperiment = dataFolder + experimentFile
# df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/flight/data.csv')
df = pd.read_csv('/content/ new test runs_2025-03-30 00:09:55.888560_.txt', sep='\t')
df = df.dropna()

LAT = '__lat,__deg'
LON = '__lon,__deg'
ALT = '__alt,ftagl'
PITCH = 'pitch,__deg'
ROLL = '_roll,__deg'
DIST = '_dist,___ft'

LATDEV = 'latdev'
LANDED = 'landed'
IDEAL_ALT = 'ideal_alt'
ZERO = 'zero'

pts = df.apply(lambda row: to_point(row[LAT], row[LON]), axis=1)

df[LATDEV] = [get_lateral_deviation(pt) for pt in pts]
df[DIST] = for d in df[LONG]
df[LANDED] = df[ALT] < 0.5

touchdown_dist = df[df[LANDED]].iloc[0][DIST]
df[IDEAL_ALT] = [
    (touchdown_dist - dist) * math.tan(3.0 * (math.pi / 180))
    if dist < touchdown_dist
    else 0
    for dist in df[DIST]
]

df[ZERO] = np.zeros(len(df))

plt.figure(figsize=(10, 12))

plt.subplot(411)
plt.ylabel('Altitude (ft)')
plt.plot(df[DIST], df[ALT])
plt.plot(df[DIST], df[IDEAL_ALT], color='tab:orange', linestyle='--')

plt.subplot(412)
plt.ylabel('Lateral Deviation (ft)')
plt.ylim(
         min(-100, df[LATDEV].min()-10),
         max( 100, df[LATDEV].max()+10)
         )

plt.plot(df[DIST], df[LATDEV])
plt.plot(df[DIST], df[ZERO], color='tab:orange', linestyle='--')

plt.subplot(413)
plt.xlabel('Distance (ft)')
plt.ylabel('Pitch (deg)')
plt.ylim(-20, 20)
plt.plot(df[DIST], df[PITCH])
plt.plot(df[DIST], df[ZERO], color='tab:orange', linestyle='--')

plt.subplot(414)
plt.xlabel('Distance (ft)')
plt.ylabel('Roll (deg)')
plt.ylim(-20, 20)
plt.plot(df[DIST], df[ROLL])
plt.plot(df[DIST], df[ZERO], color='tab:orange', linestyle='--')

plt.show()

